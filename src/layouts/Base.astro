---
import '@styles/index.css'
import "@/styles/highlight.css"
import Header from '@/layouts/partials/Header.astro'
import Footer from '@/layouts/partials/Footer.astro'
import TwSizeIndicator from '@/domain/dev/TwSizeIndicator.astro'
import { ClientRouter } from 'astro:transitions'
import FocusModeController from '@/domain/shared/controllers/FocusModeController.astro'
const { title = 'Mon Site', meta_title, description, image } = Astro.props
const pageTitle = meta_title || title
---

<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <title>{pageTitle}</title>
    {description && <meta name="description" content={description} />}
    {image && <meta property="og:image" content={image} />}
    <meta property="og:title" content={pageTitle} />
    {description && <meta property="og:description" content={description} />}
    <meta name="twitter:title" content={pageTitle} />
    {description && <meta name="twitter:description" content={description} />}
    {image && <meta name="twitter:image" content={image} />}
    <ClientRouter />

    <script is:inline>
      function initTheme() {
        const THEME_STORAGE_KEY = 'theme'
        const savedTheme = localStorage.getItem(THEME_STORAGE_KEY)
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
        const initialThemeIsDark = savedTheme ? savedTheme === 'dark' : prefersDark
        document.documentElement.setAttribute(
          'data-theme',
          initialThemeIsDark ? 'dark' : 'douceurLight'
        )
      }

      // Initialisation au chargement
      initTheme()

      // Réinitialisation après chaque navigation ViewTransition
      document.addEventListener('astro:after-swap', initTheme)
    </script>

    <!-- Global initializer for FAB Speed Dial (works across ViewTransitions) -->
    <script is:inline>
      (() => {
        function initFab(root) {
          if (!root || root.__fabInited) return
          root.__fabInited = true
          const main = root.querySelector('[data-fab-main]')
          const items = root.querySelectorAll('[data-fab-item]')

          const setExpanded = (val) => {
            if (main) main.setAttribute('aria-expanded', val ? 'true' : 'false')
          }
          const close = () => {
            setExpanded(false)
            const active = document.activeElement
            if (active && root.contains(active) && active.blur) active.blur()
            else if (main && main.blur) main.blur()
          }

          if (main) {
            main.addEventListener('click', () => {
              main.focus()
              setExpanded(true)
            })
            main.addEventListener('keydown', (e) => {
              if (e.key === 'Escape') close()
            })
          }

          items.forEach((btn) => {
            btn.addEventListener('click', () => {
              const action = btn.getAttribute('data-fab-action')
              if (action) {
                const ev = new CustomEvent('fab:action', {
                  detail: { action },
                  bubbles: true,
                  composed: true,
                })
                btn.dispatchEvent(ev)
              }
              close()
            })
          })
        }

        function scanAndInitFabs() {
          document.querySelectorAll('.fab').forEach((el) => initFab(el))
        }

        // Initial page load
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', scanAndInitFabs)
        } else {
          scanAndInitFabs()
        }

        // After every client navigation
        document.addEventListener('astro:page-load', scanAndInitFabs)
        document.addEventListener('astro:after-swap', scanAndInitFabs)
      })()
    </script>

    <!-- Global initializer for FocusEscapeHint (ESC helper on focus mode) -->
    <script is:inline>
      (() => {
        const state = (window.__focusHintState = window.__focusHintState || {
          hideTimeout: null,
          observer: null,
          keydownAttached: false,
        })

        function getHint() {
          return document.getElementById('focus-escape-hint')
        }

        function showHint() {
          const el = getHint()
          if (!el) return
          if (state.hideTimeout) {
            clearTimeout(state.hideTimeout)
            state.hideTimeout = null
          }
          el.classList.remove('fade-out')
          el.classList.add('show')
          state.hideTimeout = setTimeout(() => hideHint(), 3000)
        }

        function hideHint() {
          const el = getHint()
          if (!el) return
          el.classList.remove('show')
          el.classList.add('fade-out')
          if (state.hideTimeout) {
            clearTimeout(state.hideTimeout)
            state.hideTimeout = null
          }
        }

        function ensureObserver() {
          if (state.observer) return
          state.observer = new MutationObserver((mutations) => {
            for (const m of mutations) {
              if (m.type === 'attributes' && m.attributeName === 'class') {
                if (document.body.classList.contains('focus-mode')) showHint()
                else hideHint()
              }
            }
          })
          state.observer.observe(document.body, {
            attributes: true,
            attributeFilter: ['class'],
          })
        }

        function ensureKeydown() {
          if (state.keydownAttached) return
          document.addEventListener('keydown', (e) => {
            if (e.key !== 'Escape' && document.body.classList.contains('focus-mode')) {
              showHint()
            }
          })
          state.keydownAttached = true
        }

        function initHint() {
          // Only act when the element exists on the current page
          const el = getHint()
          if (!el) return
          ensureObserver()
          ensureKeydown()
          if (document.body.classList.contains('focus-mode')) showHint()
        }

        // Initial page load
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initHint)
        } else {
          initHint()
        }

        // Run after client navigations
        document.addEventListener('astro:page-load', initHint)
        document.addEventListener('astro:after-swap', initHint)
      })()
    </script>
  </head>

  <body class="min-h-screen">
    <!-- Global controller: resets focus-mode on navigation; only active on posts -->
    <FocusModeController />
    <!-- Layout principal avec Grid Tailwind -->
    <div class="grid min-h-screen grid-rows-[auto_1fr_auto]">
      <TwSizeIndicator />
      <!-- HEADER fixe -->
      <header class="fixed top-0 right-0 left-0 z-50 bg-transparent">
        <Header />
      </header>

      <!-- MAIN avec Hero full-width -->
      <main class="overflow-x-hidden pt-16">
        <!-- Hero full-width -->
        <div id="hero-container" class="relative">
          <slot name="hero" />
        </div>
        <!-- Contenu centré pour les autres sections -->
        <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
          <slot />
        </div>
      </main>

      <!-- FOOTER -->
      <footer class="mt-auto">
        <Footer />
      </footer>
    </div>
  </body>
</html>

<!-- CSS minimal - seulement pour les spécificités impossibles avec Tailwind -->
<style>
  /* Tailwind CSS v4 gère automatiquement le reset via @import "tailwindcss" */
  /* Plus besoin de reset manual ni de CSS custom pour le layout */

  /* Transition douce et fluide pour ViewTransitions */
  ::view-transition-old(root),
  ::view-transition-new(root) {
    animation-duration: 0.6s;
    animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  }

  ::view-transition-old(root) {
    animation-name: fade-out-smooth;
  }

  ::view-transition-new(root) {
    animation-name: fade-in-smooth;
  }

  @keyframes fade-out-smooth {
    0% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  }

  @keyframes fade-in-smooth {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }
</style>
